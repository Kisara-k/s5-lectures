## 9. NoSQL Examples

Certainly! Below is a detailed, well-organized, and clear study note based on the lecture content you provided. It covers NoSQL databases with examples of Firestore, MongoDB, and Neo4j, explaining key concepts in an accessible way and including relevant details from the lecture.



## Study Notes: NoSQL Databases and Examples ðŸ“š



### 1. ðŸŒ Introduction to the NoSQL Movement

The NoSQL movement emerged as a response to the limitations of traditional relational databases, especially when dealing with modern applications that require:

- **Greater scalability:** Handling large volumes of data and many users simultaneously.
- **High throughput and low response times:** Fast reads and writes to support real-time applications.
- **Flexible data models:** Unlike rigid relational schemas, NoSQL databases allow more expressive and adaptable data structures.
- **Solving the object-relational mismatch:** Bridging the gap between how data is stored (tables) and how it is used in applications (objects).
- **Preference for open-source software:** Many NoSQL systems are open-source, encouraging community development and adoption.

NoSQL databases come in various types, including document stores, key-value stores, wide-column stores, and graph databases, each suited for different use cases.



### 2. ðŸ”¥ Firestore: A Serverless Document Database

#### Overview

Firestore is a **distributed, serverless document database** developed by Google, designed primarily for mobile, web, and IoT applications. It offers:

- **Simple APIs** for reading and writing data.
- **ACID transactions** (atomicity, consistency, isolation, durability) supported via Google Spanner technology.
- **Change data capture** to track document changes.
- **Cost-effective** usage but limited to Google Cloud with write throughput capped at about 10,000 writes per second.

#### Firestoreâ€™s Document Model

Firestore stores data as **documents**, which are collections of typed key-value pairs. These can be:

- **Primitive types:** Strings, numbers, booleans, timestamps.
- **Complex types:** Arrays, maps (nested objects), geopoints (latitude/longitude).

Documents are grouped into **collections**, which are like tables but more flexible:

- Documents in the same collection can have different schemas.
- Each document has a unique string identifier.
- Documents can contain **subcollections**, allowing hierarchical data storage (up to 100 levels deep).

#### Writing Data

- **Single document writes:** Use the `set` method to convert a Python dictionary into a Firestore document.
- **Nested documents:** Subcollections can be nested under documents or other subcollections.
- **Batch writes:** Firestore supports writing multiple documents in batches of up to 500, which can span multiple collections.

#### Reading Data

- **Single document:** Use the `get` method.
- **Multiple documents:** Use the `stream` method to fetch all documents in a collection or subcollection.
- **Filtering and sorting:** Use `where` to filter, `order_by` to sort, and `limit` to restrict the number of results.
- **Indexes:** All queries require indexes; if an index is missing, the query will fail.

#### Updating and Deleting

- **Update:** Use the `update` method to modify fields, including incrementing numeric values.
- **Delete fields:** Use `firestore.DELETE_FIELD` to remove specific fields.
- **Delete documents:** Use the `delete` method on a document reference.

#### Data Modeling in Firestore

When converting relational schemas (like a college database) to Firestore:

- Identify **access patterns** (how data will be queried).
- Group entities into hierarchies: top-level collections and nested subcollections.
- Use primary keys or concatenated keys as unique document IDs.
- Design collections and subcollections to optimize for the expected queries.



### 3. ðŸƒ MongoDB: A Popular Document-Oriented Database

#### Overview

MongoDB is an **open-source, distributed document database** widely used for web applications. It features:

- A **document-oriented data model** using BSON (Binary JSON).
- **Schema flexibility:** MongoDB is "schemaless," meaning the schema is applied when reading data, not enforced on writes.
- A **rich query language** supporting complex queries and secondary indexes.
- **Horizontal scaling** through replication and sharding.
- Support for **multi-document ACID transactions**.
- Runs both on-premises and in the cloud (MongoDB Atlas).

#### The CAP Theorem Context

MongoDB, like other distributed databases, must balance the CAP theorem properties:

- **Consistency:** All nodes see the same data at the same time.
- **Availability:** The system is always responsive.
- **Partition tolerance:** The system continues to operate despite network failures.

MongoDB typically prioritizes availability and partition tolerance but can be configured for stronger consistency.

#### Replication and Sharding

- **Replication:** MongoDB uses replica sets to provide high availability and automatic failover. Reads can be load-balanced across replicas.
- **Sharding:** Data is partitioned across shards based on a **shard key** (one or more document fields). Documents with the same shard key are grouped into chunks, which are distributed across shards.

#### MongoDB Data Model

- Documents are BSON objects with unordered key-value pairs.
- Supports nested documents and arrays.
- Each document has a unique `_id` field.
- Maximum document size is 16 MB.
- Documents are grouped into collections, which are grouped into databases.

#### Basic Operations

- **Inserts:** `insertOne()`, `insertMany()`.
- **Reads:** `findOne()`, `find()` with selection (filter) and projection (fields to return).
- **Queries:** Support nested queries, boolean operators (`$or`, `$and`), and range queries (`$lt`, `$gt`, etc.).
- **Updates:** `update()`, `updateMany()`.
- **Deletes:** `deleteOne()`, `deleteMany()`.



### 4. ðŸŒ³ Neo4j: A Graph Database for Connected Data

#### Overview

Neo4j is a **labeled property graph database** optimized for highly connected data and graph traversals. It offers:

- A **declarative query language called Cypher**, inspired by SQL but designed for graph patterns.
- ACID-compliant transactions.
- Distributed architecture for scaling reads (but limited write scalability, no sharding).
- Visualization tools like Neo4j Browser and Bloom.
- Available as open-source and cloud service (Aura).

#### Graph Data Model

- Data is stored as **nodes** (entities) and **relationships** (edges).
- Both nodes and relationships can have **labels** and **properties** (key-value pairs).
- This model is ideal for representing complex relationships, such as social networks, IAM (Identity and Access Management), recommendation systems, etc.

#### Basic Cypher Commands

- **Create nodes:** `CREATE (n:Label {property: value})`.
- **Create relationships:** `CREATE (a)-[:REL_TYPE]->(b)`.
- **Match and return:** `MATCH (n) RETURN n`.
- **Filtering:** Use `WHERE` clauses to filter nodes or relationships.
- **Counting and aggregations:** Use `COUNT()` and other aggregation functions.

#### Example: IAM Model in Neo4j

- Nodes represent entities like `Person`, `Role`, `Group`, and `Permission`.
- Relationships represent connections like `HAS_ROLE`, `IN_GROUP`, and `HAS_PERMISSION`.
- Cypher queries can create these nodes and relationships, update properties, and query complex permission hierarchies.
- Visualization helps understand the graph structure and relationships.

#### Updating and Deleting

- Nodes and relationships can be updated by adding or changing properties.
- Relationships can be "renamed" by deleting and recreating with a new type.
- Nodes and relationships can be deleted, with care taken to remove connected relationships first.



### 5. ðŸ“ Summary and Key Takeaways

- **NoSQL databases** provide flexible, scalable alternatives to relational databases, each suited to different data and application needs.
- **Firestore** is a serverless, document-based database optimized for mobile and web apps with hierarchical data support.
- **MongoDB** is a widely-used document store with rich querying, replication, and sharding capabilities.
- **Neo4j** is a graph database designed for highly connected data, using a property graph model and Cypher query language.
- Understanding the **data model, query capabilities, and scaling mechanisms** of each NoSQL system is crucial for designing efficient applications.
- Always consider **access patterns** and **data relationships** when modeling data in NoSQL databases to optimize performance and usability.



If you want, I can also help with example code snippets or further explanations on any of these topics!

## Questions

Certainly! Here are 20 multiple-choice questions (MCQs) designed to comprehensively cover the key concepts from the lecture content on NoSQL databases, including Firestore, MongoDB, Neo4j, and general NoSQL principles. Some questions have one correct answer, others may have multiple correct answers to increase difficulty.



#### 1. Which of the following are primary reasons behind the NoSQL movement?  
A) Need for greater scalability  
B) Preference for rigid schemas  
C) Desire for more expressive data models  
D) Object-relational mismatch  
E) Exclusive use of proprietary software  



#### 2. Firestore is best described as:  
A) A relational database  
B) A serverless, distributed document database  
C) A graph database  
D) A key-value store  



#### 3. In Firestore, documents:  
A) Must all have the same schema within a collection  
B) Are collections of typed key-value pairs  
C) Can contain subcollections nested up to 100 levels deep  
D) Are identified by unique integer IDs only  



#### 4. Which of the following Firestore features are true?  
A) Supports ACID transactions  
B) Requires manual server management  
C) Limits write throughput to about 10,000 writes per second  
D) Can run on any cloud provider  



#### 5. When designing a Firestore database from a relational schema, which of the following guidelines apply?  
A) Convert each top-level entity into a collection  
B) Use subcollections to represent lower-level entities nested under parents  
C) Always flatten all relationships into a single collection  
D) Use primary keys or concatenated keys as document IDs  



#### 6. In MongoDB, which of the following statements are correct?  
A) Documents are stored as BSON objects  
B) MongoDB enforces a strict schema on writes  
C) Supports multi-document ACID transactions  
D) Sharding is automatic and requires no configuration  



#### 7. What is the role of a shard key in MongoDB?  
A) It determines how documents are partitioned across shards  
B) It uniquely identifies a document within a collection  
C) It controls replication between nodes  
D) It groups documents into chunks assigned to shards  



#### 8. Which MongoDB query operators are used for boolean logic and range queries?  
A) $or, $and  
B) $lt, $gt, $lte, $gte  
C) $in, $nin  
D) $exists, $type  



#### 9. Which of the following are true about MongoDB replication?  
A) Provides high availability through replica sets  
B) Automatically shards data across multiple nodes  
C) Supports automatic failover  
D) Balances read load across replicas  



#### 10. Neo4j is best suited for which type of data?  
A) Highly connected data with complex relationships  
B) Flat tabular data with fixed schemas  
C) Large binary files  
D) Time-series data  



#### 11. In Neo4j, what are the main components of the data model?  
A) Nodes and relationships  
B) Tables and rows  
C) Documents and collections  
D) Keys and values  



#### 12. Which of the following Cypher commands correctly create a node with a label and property?  
A) CREATE (n:Person {name: "Ethan"})  
B) INSERT INTO Person VALUES ("Ethan")  
C) CREATE NODE Person WITH name = "Ethan"  
D) ADD NODE Person {name: "Ethan"}  



#### 13. Which statements about Neo4j relationships are true?  
A) Relationships can have properties  
B) Relationships are directed edges between nodes  
C) Relationships cannot be deleted without deleting nodes  
D) Relationships can be "renamed" by deleting and recreating  



#### 14. The CAP theorem states that a distributed database can guarantee at most two of the following three properties:  
A) Consistency  
B) Availability  
C) Partition tolerance  
D) Performance  



#### 15. Which of the following are advantages of Firestoreâ€™s serverless architecture?  
A) No need to manage servers or infrastructure  
B) Automatic scaling based on demand  
C) Can be deployed on any cloud provider  
D) Fixed write throughput limits  



#### 16. In Firestore, what happens if you run a query without the required index?  
A) The query will succeed but be slow  
B) The query will fail  
C) Firestore automatically creates the index  
D) The query returns partial results  



#### 17. Which of the following are valid Firestore data types?  
A) String, Number, Boolean  
B) Array, Map, Geopoint  
C) XML, CSV  
D) Timestamp  



#### 18. When updating a document in Firestore, which of the following are possible?  
A) Incrementing a numeric field atomically  
B) Deleting a specific field from the document  
C) Updating multiple documents in a single batch  
D) Changing the documentâ€™s unique identifier  



#### 19. Which of the following are true about MongoDBâ€™s schema flexibility?  
A) It is schemaless, meaning schema is applied on reads, not writes  
B) All documents in a collection must have identical fields  
C) Supports nested documents and arrays  
D) Schema changes require downtime  



#### 20. In Neo4j, which of the following queries would return all permissions associated with a person named "Ethan"?  
A) MATCH (p:Person {name: "Ethan"})-[*]->(m:Permission) RETURN m  
B) SELECT * FROM Permission WHERE person = "Ethan"  
C) MATCH (p:Person)-[:HAS_ROLE]->(:Role)-[:HAS_PERMISSION]->(m:Permission) WHERE p.name = "Ethan" RETURN m  
D) MATCH (p:Person {name: "Ethan"}) RETURN p.permissions  



These questions cover the core concepts, data models, query languages, architecture, and design principles of Firestore, MongoDB, Neo4j, and general NoSQL ideas, including some tricky and multi-answer questions to test deeper understanding. Let me know if you want the answer key or explanations!

## Answers

Certainly! Below are the correct answers for each question along with brief explanations to clarify why those answers are correct.



#### 1. Which of the following are primary reasons behind the NoSQL movement?  
**Correct:** A) Need for greater scalability  
C) Desire for more expressive data models  
D) Object-relational mismatch  

**Explanation:**  
NoSQL arose to handle scalability challenges, provide flexible schemas, and solve the mismatch between object-oriented programming and relational databases. Preference for rigid schemas (B) and proprietary software (E) are not reasons for NoSQL.



#### 2. Firestore is best described as:  
**Correct:** B) A serverless, distributed document database  

**Explanation:**  
Firestore is a fully managed, serverless document database designed for distributed environments. It is not relational, graph, or a simple key-value store.



#### 3. In Firestore, documents:  
**Correct:** B) Are collections of typed key-value pairs  
C) Can contain subcollections nested up to 100 levels deep  

**Explanation:**  
Firestore documents store typed key-value pairs and can have nested subcollections up to 100 levels. Documents in the same collection can have different schemas, and IDs are strings, not limited to integers.



#### 4. Which of the following Firestore features are true?  
**Correct:** A) Supports ACID transactions  
C) Limits write throughput to about 10,000 writes per second  

**Explanation:**  
Firestore supports ACID transactions and has write throughput limits. It is serverless, so no manual server management (B), and it only runs on Google Cloud (not any cloud provider, so D is false).



#### 5. When designing a Firestore database from a relational schema, which of the following guidelines apply?  
**Correct:** A) Convert each top-level entity into a collection  
B) Use subcollections to represent lower-level entities nested under parents  
D) Use primary keys or concatenated keys as document IDs  

**Explanation:**  
Firestore design involves mapping top-level entities to collections, nesting related entities as subcollections, and using unique identifiers from primary keys. Flattening all relationships into one collection (C) is not recommended.



#### 6. In MongoDB, which of the following statements are correct?  
**Correct:** A) Documents are stored as BSON objects  
C) Supports multi-document ACID transactions  

**Explanation:**  
MongoDB stores data as BSON and supports multi-document transactions. It is schemaless (not enforcing strict schema on writes), and sharding requires configuration (not automatic).



#### 7. What is the role of a shard key in MongoDB?  
**Correct:** A) It determines how documents are partitioned across shards  
D) It groups documents into chunks assigned to shards  

**Explanation:**  
The shard key partitions data by grouping documents into chunks, which are distributed to shards. It does not uniquely identify documents (thatâ€™s `_id`), nor control replication.



#### 8. Which MongoDB query operators are used for boolean logic and range queries?  
**Correct:** A) $or, $and  
B) $lt, $gt, $lte, $gte  

**Explanation:**  
`$or` and `$and` are boolean operators; `$lt`, `$gt`, `$lte`, `$gte` are range operators. `$in`, `$nin` and `$exists`, `$type` are valid but not specifically boolean or range operators.



#### 9. Which of the following are true about MongoDB replication?  
**Correct:** A) Provides high availability through replica sets  
C) Supports automatic failover  
D) Balances read load across replicas  

**Explanation:**  
MongoDB replica sets provide redundancy, automatic failover, and read load balancing. Sharding is a separate feature and not part of replication.



#### 10. Neo4j is best suited for which type of data?  
**Correct:** A) Highly connected data with complex relationships  

**Explanation:**  
Neo4j is a graph database optimized for connected data and relationships, not flat tabular, binary files, or time-series data.



#### 11. In Neo4j, what are the main components of the data model?  
**Correct:** A) Nodes and relationships  

**Explanation:**  
Neo4j stores data as nodes (entities) and relationships (edges). Tables/rows and documents/collections belong to relational and document databases, respectively.



#### 12. Which of the following Cypher commands correctly create a node with a label and property?  
**Correct:** A) CREATE (n:Person {name: "Ethan"})  

**Explanation:**  
Cypher uses `CREATE` with parentheses for nodes, labels after colon, and properties in curly braces. Other options are invalid syntax.



#### 13. Which statements about Neo4j relationships are true?  
**Correct:** A) Relationships can have properties  
B) Relationships are directed edges between nodes  
D) Relationships can be "renamed" by deleting and recreating  

**Explanation:**  
Relationships in Neo4j are directed, can have properties, and to rename a relationship type, you delete and recreate it. Relationships can be deleted independently of nodes, so C is false.



#### 14. The CAP theorem states that a distributed database can guarantee at most two of the following three properties:  
**Correct:** A) Consistency  
B) Availability  
C) Partition tolerance  

**Explanation:**  
CAP theorem limits distributed systems to two of these three: consistency, availability, and partition tolerance. Performance is not part of CAP.



#### 15. Which of the following are advantages of Firestoreâ€™s serverless architecture?  
**Correct:** A) No need to manage servers or infrastructure  
B) Automatic scaling based on demand  

**Explanation:**  
Firestore is serverless, so no server management and it scales automatically. It only runs on Google Cloud (not any cloud), and has fixed write throughput limits, so C and D are false.



#### 16. In Firestore, what happens if you run a query without the required index?  
**Correct:** B) The query will fail  

**Explanation:**  
Firestore requires indexes for queries; if missing, the query fails rather than running slowly or partially.



#### 17. Which of the following are valid Firestore data types?  
**Correct:** A) String, Number, Boolean  
B) Array, Map, Geopoint  
D) Timestamp  

**Explanation:**  
Firestore supports primitive types like string, number, boolean, timestamp, and complex types like arrays, maps, and geopoints. XML and CSV are not data types.



#### 18. When updating a document in Firestore, which of the following are possible?  
**Correct:** A) Incrementing a numeric field atomically  
B) Deleting a specific field from the document  
C) Updating multiple documents in a single batch  

**Explanation:**  
Firestore supports atomic increments, deleting fields, and batch updates. Document IDs cannot be changed once created, so D is false.



#### 19. Which of the following are true about MongoDBâ€™s schema flexibility?  
**Correct:** A) It is schemaless, meaning schema is applied on reads, not writes  
C) Supports nested documents and arrays  

**Explanation:**  
MongoDB does not enforce schemas on writes, allowing flexible document structures including nested objects and arrays. Documents in a collection can differ, and schema changes do not require downtime.



#### 20. In Neo4j, which of the following queries would return all permissions associated with a person named "Ethan"?  
**Correct:** A) MATCH (p:Person {name: "Ethan"})-[*]->(m:Permission) RETURN m  
C) MATCH (p:Person)-[:HAS_ROLE]->(:Role)-[:HAS_PERMISSION]->(m:Permission) WHERE p.name = "Ethan" RETURN m  

**Explanation:**  
Both queries traverse relationships from Person to Permission nodes. A uses variable-length paths, C uses explicit relationship types. B and D are invalid Cypher or incorrect syntax.



If you want, I can also provide explanations for incorrect options or more detailed examples!